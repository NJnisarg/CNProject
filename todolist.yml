todo:
  - Implementation:

  - Testing:
    - Validate if the cuckoo hashing works or not
    - Validate the segment of code that marks flow as empty on dequeue
    - Validate the cuckoo rehash(on double collision)

done:
  Implementation:
    - Add a hashtable to the sched_data struct
    - Initilialize the hashtable in the init function of fq_codel
    - Add the bitmask array to hold the empty flows info in the sched_data struct
    - Add the second level index to the bitmask array in the sched_data struct
    - Initialize the bitmask in the init function
    - Initialize the bitmask index in the init function
    - Resetting the values of hashtable, bitmask and bitmask index in the fq_codel_reset function
    - Modify the hash function to allow hashing into 2 tables
    - Create a wrapper cuckoo hash function that uses the cuckoo hashing scheme.
    - Use the cuckoo hashing wrapper in the fq_codel_classify
    - Write the cuckoo rehash function to handle double conflicts and onwards
    - Create a function a wrapper to the empty flow index from the bitmask using the above mentioned function.
    - Create a function to unset a given bit at a given location to indicate the flow is under use.
    - Create a function to set a given bit at a given location to indicate the flow is not under use.
    - Update the bitmask values when the packet is actually enqueued in the fq_codel_enqueue
    - update the hashtable values when a flow becomes empty at dequeue
    - Update the bitmask values when the flow becomes empty at dequeue
    - Use the kernel ffs - find first set. Include the headers or something for that.
  Testing:
    - Validate the get_next_empty_flow
    - Validate the mark_flow_as_non_empty
    - Validate the mark_flow_as_empty
    - Validate the Resetting
    - Validate the initialization of hashtable and bitmasks

notes:
  - Check the implementation of the bitmask. Get it validated.
  - Talk about using 2 hash functions. How to do this?